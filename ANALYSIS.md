*Analysis for Cell Society by Brandon Choi, Team 03*

##Project Journal

**Time Review**

My team and I started this project on 1/23/15 and turned in our most up-to-date code on 2/9/15. We spent approximately 85 hours throughout the course of the project. 

Initially, we spent over four hours just planning the design of our implementation. [Sprint 1](http://www.cs.duke.edu/courses/compsci308/spring15/assign/02_cellsociety/part1.php) took over four hours for my team. When writing the design document, we were together and collaborated on each aspect of the design in order to ensure that all members were equally aware of both the projected front and back end components. We made sure to keep in mind how scalable our code would be for possibly more complex simulations. Therefore, we ended up creating numerous abstract classes such as CellWorld or Occupant. The decision to utilize abstract classes as well as packages to organize inhertiances made our future implementions much cleaner and easier to read. 

For [Sprint 2](http://www.cs.duke.edu/courses/compsci308/spring15/assign/02_cellsociety/part2.php), we spent about a quarter of the time coding in our own time and during the rest, we were collaborating with each other, asking and answering questions about our implementation, and stitching together the different parts of the project we individually coded. Spring 2 was where we spent the majority of the time actually coding in new features, testing, and debugging. Because we had spent such an extensive amount of time creating a scalable and efficient design in Sprint 1, we were able to focus the majority of our time during Spring 2 to actually coding the planned features. In comparing the amount of time each sprint took our team, Sprint 2 was most likely the most time consuming. This was not a surprise to us because Sprint 2 was when we transitioned from design ideas to actual software implementation.

[Sprint 3](http://www.cs.duke.edu/courses/compsci308/spring15/assign/02_cellsociety/part3.php) took us the second longest among the sprints. Unlike Sprint 2 in which we spent the majority of the time coding in new features, Sprint 3 comprised mostly of refactoring and debugging. My team knew we wouldn't have enough time to implement all the new features of the sprint and clean our code and so we chose to prioritize efficient design and overall quality over the pure quantity of newly implemented features. We spent the bulk of redesigning certain components of our project in order to give our program the ability to easily add the new simulations. We never got around to actually implementing any new cell automatas but the final product we turned in was definitely cleaner and thoroughly refactored to be devoid of repeated code. 

The easiest taks for me was implementing the algorithms behind each cell automata simulation. For example, I coded a bulk of the back end for FireCellWorld and GameOfLifeCellWorld and I really enjoyed thinking through the logic behind the changes in states. Therefore, implementing the different classes to represent the states as well as the code to represent the logic behind changes wasn't difficult for me. I would love to have worked on different simulations such as the predator-prey model because that and segregation definitely had new components to the simulation that would've been interesting to work with. My teammates implemented those and I dealt mostly with the simulations that had states rather than moving characters. For me, the hardest part was keeping track of how the different classes and components of the project would interact. Because we ended up utilizing so many abstract classes, we also ended up with countless subclasses. I found it difficult to remember where certain functions were implemented if I ever needed to test new features or debug. I think it was wise for my team to spend so much time working on Spring 1 and the design document. This definitely helped speed up the implementation process in Sprint 2 and after we got our first simulation working, finishing up the rest of Sprint 2 was not too difficult. However, I do think we should've spent more time during Sprint 2 in cleaning up our code. I myself was too focused on implementing functional features that I had to spend more time in Sprint 3 to compensate for my messy code rather than focus on extending the program's adapability.


**Teamwork**

Like stated above, my team spent over four hours planning and the designing the project before we even wrote a single line of code. Our main meeting to finish our design document was on the 25th but we had talked a few times before the meeting about how we wanted our project to be eventually designed as well as how that design would transition into actual implementation. 

Nathan Prabhu and Catherine Zhang were my two teammates. They were absolutely fantastic teammates to have as they were both responsible, easy to work with, and also extremely analytical and creative thinkers. Catherine intiially focused on reading and parsing the XML file as well as the grid display in the GUI. Later on, Catherine also took charge of designing and implementing the new grid shapes (triangular, hexagonal). She helped implement the back-end algorithms to SegregationCellWorld. Nathan was initially in charge of a lot of the front-end components such as the user interface but also worked with the UIManager, which acted as the controller component in our model-view-control architecture. He also implemented the algorithms for predator-prey and later redesigned and refactored Cat's XML parser into its own class. I implemented the back-end for FireCellWorld and GameOfLifeCellWorld. Later on, I focused my time in refactoring a large design component of our project in trying to change Grid<Occupant> to Grid<Location>. This would've made the program iterate through each location and whatever it's occupant or state was rather than iterate through just occupants. This was necessary for simulations in Sprint 3 where the concept of a "patch" was added. By iterating through locations and being able to change or add attributes at each place, the program could run simulations that were more complex without having to completely redesign the project. In the end, this large refactoring was unfortunately not committed or pushed because it was buggy when running SegregationCellWorld.

Overall, I felt like our communication within the team was great. We had a GroupMe going so that we could ask each other questions about code, suggest design or implementation ideas, and also ask for updates on our individual progress. Between Sprint 2 and Sprint 3, however, I felt that Catherine was absent at times but in the end, she always delivered the parts of the project she had assumed responsibility for and contributed greatly to the overall team efforts and accomplishments. 

I felt that while other teams were splitting up the project to front-end and back-end components and assigning people one or the other, everyone in my team worked with both spectrums. Though each of us chose to focus on certain aspects of the project, each member of my team also had at least one simulation to implement as well as front end aspects to work on. Our plan was to abstract our classes enough so that once we had one simulation working, we could ideally get the rest of the simulations to work without excessive effort or drastic design changes. We chose to work on FireCellWorld first. Cat was in charge of parsing the XML file into the paramters needed, I was in charge of implementing the algorithms and classes necessary for FireCellWorld, and Nathan was in charge of the UIManager and the GUI itself. After we knew what each of us had to do, we coded our parts on our own time and met a few days before Sprint 2's deadline to put all those components together.We initially ran into a few bugs regarding the proper display and placement of front-end components but we were able to sucessfully simulate FireCellWorld in a relatively short amount of time. Our dedication to the design component of the project really pulled through and was effective in aiding our implementation process. From there, each of us took on another simulation and we were able to have all four simulations running by Sprint 2's deadline. Similarly, for Sprint 3, each of us took on very separate aspects of either the refactoring or implementing process and met to merge such changes together. However, due to the complexity of Sprint 3, we were unable to fully implement all the changes we wanted such as my change from Grid<Occupant> to Grid<Location>. For us, Sprint 3 demanded more design changes rather than actual implementations and so splitting up our parts proved difficult because the design changes we individually decided on didn't always match up.However, overall, I believe our plan to divide, reconvene, and conquer was effective as proven by our varying degrees of success in Sprint 2 and 3. 


**Commits**

I ended the project with a total of 68 commits, 3,696 additions and 2,176 deletions. This averaged out to become about 54 additions and 32 deletions per commit. I managed all my code on a separate branch in the project called cellsociety_brandon. I worked on a separate branch in order to ensure that the master code would not be ruined if I ended up implementing an unsuccessful design change or feature. I was mindful to push everytime I added a new significant feature or made a significant change to any class or program component. I will admit that at times, I forgot to adhere to this rule and ended up occasionally pushing very large changes onto my branch. As for merging my changes with master, my team had a policy that every pull request from our branches had to be approved through comments on GitHub or verbal ok's when we were meeting together. This made it so that everyone was aware of every change that was being made to our master branch. 

Looking back on my commit messages, I feel that most of them accurately portray the changes and my contributions to the project while a small portion of them do not specify what exactly I changed because the commit was so large that my comment couldn't elaborate on everything. Moreover, some of my commit messages were rushed during team collaborations and/or moments approaching deadlines and so some of them are vague in description.

[Commit #1](https://github.com/duke-compsci308-spring2015/cellsociety_team03/commit/c3421789378b2c5ae77cdad10cb6414089684e3b): The purpose of the commit was to add all the code that enabled the Game of Life simulation to function correctly. My commit did not cause merge conflicts for others in the team as I was the only one working on the Game of Life simulation and so no one else made drastic changes to the involved classes. I believe that my commit was done in a timely manner relative to the rest of the team's progress as this was the second simulation to function properly after our initial success with FireCellWorld.

[Commit #2](https://github.com/duke-compsci308-spring2015/cellsociety_team03/commit/81cc29906a1f8105e1446d5ff5bbb43e6553d4d6): The purpose of this commit was to implement a functional step button that would advance the animation by only one frame per click. This again did not cause any merge conflicts as I was the one working on this component. This was done in a timely manner before we finished all our initial simulations. This was extremely useful to the rest of the team in debugging cell automata simulations. This enabled us to see if cell automata behaviors were being implemented correctly by allowing us to check the animations one frame at a time for correct changes in states or movements. 

[Commit #3](https://github.com/duke-compsci308-spring2015/cellsociety_team03/commit/36ea49961225c18db68bce5ab4b02326ccdcc036): The purpose of this commit was to clean up and refactor the code for the two states in Game of Life. This did not cause any merge errors because I was in charge of and the only one working on the Game of Life simulations and so no one else had made any changes to the code. This was done in a timely manner relative to the rest of the team's progress as the rest of my team was also fixing little bugs and cleaning up code in the simulations they had worked on. This commit added another abstract class to the project called LifeState but in the end, this addition ended up removing repeated code in Alive and Dead as well as making those two classes much more readable.


**Conclusions**

I underestimated the size of this project because I had never previously been expected to design and implement a software project that was meant to be scalable to previously unprovided conditions. Therefore, though creating the project with Sprint 2 was difficult and frustrating at times, Sprint 3 and its drastic new requirements was really the most difficult hurdle to overcome. 

I do believe I took on enough responsibility within my team. I made sure to always offer my help and ideas if any of my teammates were stuck on an issue. I took on tasks that I was confident I could fulfill and contributed greatly to the overall design in the beginnings of the project. In addition, though my contribution in the end was not actually committed to be graded, I still took on that challenge in redoing our program's design and spent the majority of my time in Sprint 3 working on that change. If it were to have been 100% successful, this change from utilizing Occupants to Location would've allowed our program to be extremely scalable and easily adaptable to any of the three new simulations. I was also very present in our group messages and made sure to keep my team updated on my progress as well as any concerns or questions I had. I knew that working in a group setting for computer science would be a new experience for me so I was sure to always keep my team updated in case they wanted to offer alternatives or saw any flaws in my ideas that I had overlooked.

My code for FireCellWorld and GameOfLifeCellWorld both initially had a lot of repeated code. It was actually brought up in recitation before I was able to fix it. My team and I were both aware of the issue but prioritzied functionality over cleanliness of our code. Therefore, when refactoring and editing my personal code, I often had to add parameters or in the case of Game of Life, a new abstract class in order to rid my code of repeated code. For example, I ended up creating a createStates method in FireCellWorld rather than having three separate ones for Burning, Tree, and Empty because the actual code for creating these were identical minus the names.

To be a better designer, I should start planning out my methods more carefully and in a detailed manner before actually writing the code. This would ensure my end product does not need as much refactoring. However, I should continue spending lots of time with my team members in the overall design of the project so that the implementation aspects are a bit easier to grasp and understand. Finally, I should stop prioritizing functionality over design because in the long run, efficient design is more important.

To be a better teammate, I should start being more proactive in suggesting recommendations for other people's duties in order to offer a new perspective in tackling issues. I should continue my constant communication and updates with my team but should stop trying to take on too many responsibilities. Taking on a bit fewer duties and focusing my energy and time into implementing a few features efficiently would allow the overall progress of the project to quicken.

If I could work on one part right now to improve any aspect of my project, it would be to finish implementing my changes to allow our program to work with Grid<Location> and not Grid<Occupant>. Like I have mentioned before, if this change was to have been fully successful, we could've implemented any of the three new simulations in Sprint 3 much more easily than we could have with our current code. This design would have been much more scalable for future additions and in retrospect, my entire team realized that we should've started with Grid<Location> in the first place. Our current program and code is very functional but this design change would've made our program very robust and compatible with other, more complex cell automatas. 


## Design Review

**Status**

Our code is generally consistent in layout, naming convention and descriptiveness, and style. We have numerous packages that are organized by types of objects. For example, the cellWorld package contains the abstract class CellWorld and all its subclasses and the occupant.state.fire package contains all states used in the FireCellWorld simulation. The naming conventions for our classes were straightforward and our we utilized a wide range of verbs to accurately describe each method's purpose. The layout of each of our classes, especially between parent classes and subclasses, were consistent as well. As for variables, we could've done a better job keeping them consistent. For [example](https://github.com/duke-compsci308-spring2015/cellsociety_team03/blob/style_XML/src/occupant/Occupant.java), we often switched between using Location loc and Location l rather than sticking with one consistent variable name when referencing a Location parameter. Our naming conventions could've used improvement but for the most part, looking back on all our classes and methods, I believe that their names are self-explanatory to the reader as well. For style, we made sure to constantly utilize the CheckStyle rules provided for CS308 to keep all our individual works' styles consistent. 

I believe that my team's code is generally readable throughout all the classes. We did, however, also provide comments for many of the methods and classes in case further description was necessary to clarify the function. The packages further help to organize and illustrate the clean structure of our code. Their names such as occupant.character.segregation show the hierarchy of how and where Occupant is being used. We utilized the classic set and get methods where it was necessary and felt that it was very easy to understand what those methods were doing based on their names as well. Also, because we used so much abstraction, we made sure to give abstract methods broad but still informational names. Finally, because we utilized so many helper methods and classes, our code is generally easier to read and process as it is split up into multiple parts and thus allows readers to focus on specific parts of the functionalities separately. An example is [UIManager](https://github.com/duke-compsci308-spring2015/cellsociety_team03/blob/style_XML/src/uiManager/UIManager.java), in which the constructor calls on multiple methods such as readParamsXML or setCellWorld. Technically speaking, all of these helper methods could have been added to one extremely long but functionally equivalent method. However, by dividing it up into helper methods with clear names, it allows the user to more easily understand what each method is doing and if the user wishes to change one of those method's functions, you do not have to sift through long methods but merely the one concise helper method. 

I believe the dependencies in our code are easy to find. Our packages are designed to contain abstract classes and its subclasses that extend it. For example, our cellWorld package has our abstract class CellWorld as well as all the specific cell worlds for all the diffirent simulations such as FireCellWorld or SegregationCellWorld. We utilized a lot of abstract classes in designing our program as to make it as scalable and adaptable as possible. Therefore, reading the constructors for the abstract parent classes allows the reader to easily see which other classes this parent class and its subclasses are dependent on. Though we could have used global variables and just a single package to hold all our classes, our usage of multiple packages and get methods (only when necessary!) are better design choices because they prevent classes from having access to data they should not be able to reach. By doing this, we did our best at avoiding the said "back channels."

Because we utilized so many abstractions, many of our features are easy to extend if given a new cell automata simulation to implement. Our hierarchy in classes such as CellWorld or Occupant allows us to easily add new types of simulations. However, as proven by our challenges during Sprint 3, certain aspects of CellWorld such as the concept of "patches," locations that hold attributes, are hard to extend due to our current design utilizing Grid<Occupant>. This would have been possible if my implementation and change to Grid<Location> was successful. However, for the most part, I believe that adding new states and characters is especially easy to extend in our program due to our abstractions in Occupant, State, and Character. However, a big drawback is that though new features are easily extendable, our program is designed so that a new class is required for every extension. 


[Class #1: Units](https://github.com/duke-compsci308-spring2015/cellsociety_team03/blob/style_XML/src/visualUnits/Units.java): </br> 
I chose this class because the way we implemented these visual units drastically changed between Sprint 2 and 3. Originally, we utilized a GridDisplay class with a subclass of GridUnit within the GridDisplay class. However, with the addition of new grid unit shapes, we created a general abstract Units class to represent the basics of any visual unit regardless of shape. In the long run, this is a much better design decision than what we had in the past as it allows our visual grid unit to be scalable to multiple shapes beyond a rectangle, triangle, or hexagon. I would suggest that the author to add at least one comment at the top explaining what this class is and why it is abstract. Especially when projects like Cell Society grow to become more and more complex, I believe it is important to specify to the reader the basics of each class because the work for the project will likely be spread out and so not everyone will be an expert on every class. I actually think the simplicity of this class and its broadness would allow it to be easily compatible with other projects. It does not utilize any Cell Society specific components such as Grid<E> and can easily be used to represent a shape in other programs. However, since it is an abstract class, definitely commenting and elaborating on the abstract method create() and its possible uses in various situations would help programmers utilize this class for other projects. 

[Class #2: UserInterface](https://github.com/duke-compsci308-spring2015/cellsociety_team03/blob/style_XML/src/userInterface/UserInterface.java): </br>
I chose to review this class because it was essentially the main component of our "view" aspect in our program. The GridDisplay that I talked about above is just one component of the entire GUI that the program user interacts with. I thought our UserInterface class was especially good because we made it abstract and therefore saved ourselves from having to repeat an immense amount of code in all the subclasses. Making it abstract was a smart decision in terms of design because different cell automata simulations could possibly require different parameter changes or options. For example, the spread probability in FireCellWorld is controlled by a slider that is obsolete in any other simulation we have. Therefore, it makes no sense to include that in the user interface of other simulations. Abstracting the user interface allows all user interface subclasses to have the same general functionalities but still provides the flexibiliy needed to customize different GUI's for different cell automatas. I would suggest that the author of this code first organize the methods by putting all abstract ones at the top below the constructor and then listing all the implemented methods. This makes abstract classes easier to read and understand because the reader can then tell which aspects of the user interface the subclasses can customize. Next, I would suggest that the set and get methods of the same field be written right above and below each other so that the list of methods have some sort of formal structure to them. In order to make this code reusable in a different project, I believe the many more methods would have to become abstract. This class was written to be used for cell automata simulations and so many of the interface components such as makeGridDisplay() or the setParameters(Parameterlist list) are not applicable to many other projects. One idea would be to make this entire abstract class an interface that can be implemented. Using an interface would allow the structure to remain adaptable as methods such as resetSimulation() or makeButtonsPanel() is probably applicable to most GUI's. Moreover, the actual implementation of code would not be included in an interface and thus would allow the user to customize the subclasses without having to edit any given code. 

**Design**

We implemented a model-view-controller architecture for our Cell Society program. This is similar to simulation, configuration, and visualization as well. The overall design was organized in this manner:

Visualization: This represents the front-end components of the program. The userInterface and visualUnits packages as well as all the classes within them were what constituted our front-end. By themselves, all of these components have no functionalities and merely represent what the user are seeing. 

Simulation: This represents the back-end spectrum of the program. The cellWorld, grid, and occupant packages and its classes are all included in simulation. This component of the program holds all the logic and algorithms for how cells behave in the various cell automatas. Some examples of the crucial functionalities that the simulation holds are how to calculate neighbors in order to determine cells' next moves, the iteration through which the cells' changes are implemented, and how to check if a simulation is complete.

Configuration: This acts as the controller role in the model-view-controller. It is the middle man between the front-end and the back-end. The uiManager is our project's controller and facilitates the interactions between the user and the program. The xmlreader package and its classes are part of the contoller component as well. Any changes the user desires is processed by the controller as it takes the actions received on the front-end and translates them into the appropriate transformations in the back-end. The XMLReader file takes in an external file and translates the data into a format the code can recognize and utilize. Therefore, this is another perfect example of how the front-end (external) is translated into the back-end (the actual code that holds the data and algorithms).

The process of presenting a visual representation of any of our cell automatas started with our Main class. The Main class created a UIManager which read in an XML file using the XML reader. From there, the correct CellWorld is created and once that occurs, the appropriate Occupant subclasses are readily available for the cell automata to begin using. The front-end component is initialized once the XML file is read in and dynamic changes to the program are able to be made by uploading a new XML file or utilizing the parameter change options available on the GUI (the sliders, text inputs). 

A new simulation could be added to our program by creating a new subclass of CellWorld to represent that specific cell automata. Then, new subclasses of Occupant (whether State and/or Character) would have to be created for each unique Occupant in that simulation. These classes would have to include the algorithms for determining movement or change in the Occupants. Next, a new subclass of UserInterface would have to be created. The XML reader would need to be editted in order to compensate for changes in parameter inputs from XML files. The addition of these classes and the edit to the XML reader would enable our program to ideally run a completely new cell automata simulation. The front-end would remain relatively uniform unless new parameter changers had to be added. In that case, an X number of subclasses needed could easily be implemented to adapt to those needs. The back-end is what would change the most as new algorithms would have to be written for the new Occupant subclasses. The CellWorld subclass wouldn't be drastically different from others that currently exist but has the potential to be depending on the new rules of the simulation. The controller in UIManager would function the same way and the XMLReader would need a few edits to take in whatever parameters the new simulation demands. 

After having spent hours on our overall design before we even started coding, we realized that our program design had to be able to be adaptable for a wide range of simulations. Therefore, we started with creating multiple abstract classes to represent the basics of any simulation. A CellWorld subclass would represent the simulation world and contain specific rules on when the simulation was over as well as the implementation of the abstract methods from the abstract CellWorld class. Occupant subclasses had to be created in order to represent a Character (any moving object within the simulation such as a shark in predatory-prey) or State (such as Burning or Tree in fire world). Character and State were also made into abstract classes because we knew that the two types of Occupants had different behaviors but also that there could be multiple States or Characters in simulations. Next, our front-end component's main part was the display of the CellWorld's grid. The UserInterface was made into an abstract class because each simulation would require different parameter changers as well as the addition of possible new features such as a data graph. The Grid and Location classes and subclasses were essential in setting up the interactions between Occupants. These were all the essential components to every single simulation possible (think of having to simulate predator-prey without a way to represent a shark or a fish!). By abstracting these, we ensured that our program would be scalable to multiple cell automatas by always containing such core components but still allowing each unique simulation to add necessary features. 

Our code was designed and implemented in this model-view-controller architecture because we realized that the interactive GUI component would prove difficult if the back-end and front-end were not separated. Moreover, with the separation in mind, we knew we had to connect the two spectrums somehow and settled on our UIManager controller class. We utilized lots of abstractions in order to strengthen our code's adapability to new simulations and demands. The use of packages allowed us to organize our code files in an efficient manner and also allowed us to utilize protected variables and methods properly. Though our design utilizes an immense number of classes, we believe that its scalability outweighs the amount of code we have to write. Additionally, the large amount of code we write for our numerous classes is not repetitive code but rather, the unique implementations of specific subclasses. Although we were aware of the possibly excessive number of classes we ended up having, we still believed our extendable design approach compensated for that issue. We did, however, realize one very big design flaw. Currently, all the Grid instances are Grid<Occupant>. My team and I realized this was a major flaw in our design if we wanted to make our program more scalable and adaptable. Utilizing a Grid of Occupants rather than Locations poses an issue when a new simulation demands that Locations hold attributes that can change over time. Rather than iterating through Occupants, we would not be required to iterate through each Location. We discovered this late into Sprint 3 and so the new implementation was not complete and therefore unfortunately not pushed. This assumption we made early on in our project hurt us in the long run as it created a strong dependency on Occupants that hindered us from being able to correctly implement the new simulations in Sprint 3.

Feature #1: Different simulations based on different rules: 

In order to implement the different simulations, the occupant, cellWorld, and grid packages are necessary. Specific subclasses of CellWorld and Occupant represent the unique aspects of each simulation such as Burning, Tree, and Empty in FireCellWorld or SegregationCellWorld for the segregation cell automata. This feature was implemented using abstraction of CellWorld and Occupant as well as an interface for Grid. It is assumed that each simulation will have a different subclass of CellWorld and numerous subclasses for Occupant as well. This design is extensible to more simulations but would require the creation of more subclasses for CellWorld and Occupant to represent the unique cases. It is also clear how to extend the code as both CellWorld and Occupant have abstract methods that differ for each simulation that are required to be implemented within the hierarchy.  


Feature #2: Reading in an XML file to start program: 

The xmlreader package and all of its classes are required for this feature to function. The XMLReader is the main component of this package and its code parses the XML file given into a ParameterList object that will later determine which CellWolrd is created as well as all of the intial parameters. Most of the reading for the XML file is actually encapsulated because the UIManager is what actually calls the methods to load the XML and read it in. Therefore, the actual hard code for the logic in XMLReader is not visible within UIManager. However, upon looking at the code in XMLReader, for the reader to successfully produce a ParameterList object, there are specific case conditions it must meet. Therefore, this is not the most flexible program in reading in an XML and returning its data because it requires numerous other specific conditions to be met. Finally, this affects its extensibility because in order for it to become more adaptable, the specific case must be hard coded into the XMLReader class. 


**Alternate Designs**

Our original design did not handle all of the project's extensions very well. Our design was easily extendable to add new simulations that were similar to the first four in terms of features used. However, when presented with new challenges such as having a location in the world be able to hold attributes (such as sugar/spice or pheromone levels), our design was not sufficient. Like I have mentioned many times before, our heavy dependency on Grid<Occupant> truly hurt our scalability in the end while Grid<Location> would've ideally allowed us to iterate through each Location and update that region as well as whatever Occupant was at that Location. After we got our first simulation working in Sprint 2, the rest of them followed rather easily due to our efficient design at that point. However, the new challenges posed a challenge we hadn't considered before and therefore required us to drastically refactor and redesign our project. We had never considered a Location to be nothing more than the coordinates that an Occupant was at and this greatly hurt our progress in Sprint 3. 

Design Decision #1: Having a separate class that reads in the XML and parses it

An alternate design idea proposed was to have each subclass of CellWorld parse its own XML file and retrieve its necessary parameters itself. The benefits of that idea were that we would not have to design and implement an XML reader that would be able to serve all CellWorld subclasses and we would not have to add another class to our extremely long list of files. The cons were that there would be numerous cases of repeated code due to the similarities in parsing parameters from the XML file. I preferred creating an XML file reading class and that is what ended up happening. It seemed more logical to create another class and avoid nasty code reptition rather than manually implement a parser for each cell automata simulation only to stop ourselves from making just one more class. 


Design Decision #2: Separating Character and State as two abstract subclasses of Occupant

We faced this problem early on when we were drafting our design document. We understood that there would be simulations in which a character-like object would move around and interact with other characters and also simulations in which immobile states would exist that change depending on neighboring conditions. The two shared a lot of similarities in that they were what changed and defined the simulation but also differed in terms of their ability to move and their algorithms behind interactions with other Occupants. We ended up splitting them up into two separate abstract classes which is what I would have preferred anyway. The benefits of having two separate classes is that though some of the code may be faintly similar, dividing the two roles up allows implementations for future simulations who only use one or the other to be created much more easily. However, a con would be if a simulation had an Occupant that had both the functionalities of a Character and State. This would hinder our program's scalability and force us to refactor how we appraoched the subclasses of Occupant.


One of the main issues in the project's current design is that Grid is still not dependent on Location and so our program is unable to iterate through every single Location and update and/or change its attributes based on whatever conditions the simulation requires. This would ideally be implemented if we were to have finished redesigning our program to utilize Grid<Location> and not Grid<Occupant>. A second important issue is that every time we want to implement a new simulation, we have to create a multitude of new classes such as a new CellWorld extension, a new UserInterface subclass, and an unknown number of Occupant subclasses as well. This could be fixed by trying to make one of our abstract classes into a non-abstract class with more parameters that alter algorithms depending on such inputs. 


## Code Masterpiece

One drastic change I made when creating my masterpiece was making FireCellWorld.java and GameOfLifeCellWorld.java both obsolete. I instead created a StateCellWorld.java class which takes in an extra String parameter to indiciate whether it should function as a FireCellWorld or a GameOfLifeCellWorld. When comparing my previous FireCellWorld and GameOfLifeCellWorld classes, I realized that the step method (given below) was exactly the same. This was as I intended it to become because utilizing Grid<Location> and iterating through all Locations allow the method to become basically uniform for any cell automata simulation. 

```java
	public Grid<Location> step () {
	        myLocations = myGrid.getOccupiedLocations();
	        ArrayList<Location> copy = new ArrayList<Location>();

	        for (Location l : myLocations) {
	            l.updateOccupant();
	            copy.add(l);
	        }

	        for (Location l : copy) {
	            State s = (State) l.getOccupant();
	            State newState = s.getNextState();
	            l.setOccupant(newState);
	        }

	        myGrid.setLocations(copy);
	        return myGrid;
	    }
```

Therefore, the only difference between the two CellWorld subclasses was the String parameter called check. It was BURNING in FireCellWorld and ALIVE in GameOfLifeCellWorld. The checkFinished() method was the same otherwise and merely needed one change in the parameter to allow this function to work for both simulations. 

```java
	public boolean checkFinished () {
        for (Location l : myGrid.getOccupiedLocations()) {
            if (l.getOccupant().getType().equals(check)) {
                return false;
            }
        }
        return true;
    }
```

Thus, I added a second parameter to StateCellWorld. After the XML reader parses the file, if it recognizes the desired simulation as Game Of Life or Spreading of Fire, then it intializes a StateCellWorld with the ParameterList object as well as a String to indicate which one it was by putting GOL or fire, both of which are now constants in the XMLReader class to indicate GameOfLifeCellWorld and FireCellWorld respectively. The addition to the constructor that is shown below then decides what the String check becomes.

```java
	if (type.equals(FIRE)){
            check = fireCheck;
        }
        else if (type.equals(GOL)){
            check = golCheck;
        }
```

I think putting this conditional statement in and combining the two CellWorld subclasses illustrates excellent design practices because it demonstrates my ability to weigh the pros and cons of implementing conditionals versus having two separate classes and using polymorphism. In this case, since the difference was so minor, I believe that this was the correct decision. Everything except that one String in checkFinished() would have been identical between FireCellWorld and GameOfLifeCellWorld and so I prioritized avoiding code reptition over the addition of a conditional statement. 

Moreover, another big change I made was getting rid of the LifeState.java class. Looking back on my code, I realized the only functionality and use of having an abstract LifeState class and having Alive and Dead extend that was to be able to count the number of Alive neighbors. Since counting Alive neighbors occurs only in Game of Life, I previously thought that implementing this counting method in the general State class would be poor design since it would only be used by one specific simulation. However, upon further analysis, I concluded that future simulations might want to also count the number of a certain type of neighbor. Therefore, I moved this counting method to the general State class and also made it more flexible towards counting the instances of any State. The new code is provided here below:

```java
	public int getNeighboringNumberOf (State s) {
        setNeighbors();

        int number = 0;
        String check1 = s.getType();
        for (Location l : getNeighbors()) {
            String check2 = l.getOccupant().getType();
            if (check1.equals(check2))
                number++;
        }

        return number;
    }
```

As you can see, now this method counts the number of neighbors that are of type State s rather than just the specific subclass Alive like it was previously. I also renamed the method to allow the reader to better understand immediately what the method was doing. LifeState was a class that I had implemented on my own when I was coding Game of Life and so for me to realize that design flaw demonstrated to me an improvement in my design knowledge and decisions. 

Moreover, by deleting the LifeState class as well as making FireCellWorld and GameOfLifeCellWorld obsolete, I essentially ridded our team's program of three extraneous java files. This definitely addressed our ongoing concern regarding our rather excessive number of classes. Finally, though I wasn't able to fully implement the change to Grid<Location> in time, the branch that I am pull requesting from contains all the updated code I had up until the point of submission for Sprint 3. Three of the four simulations function when using Grid<Location> and though this design change is not portrayed in the masterpiece we will demo, the change was something my team and I were both aware of and in the process of implementing. The code that I will be pull requesting from demonstrates my attempt at refactoring all of our classes to work with Grid<Location>. 

The changes made in my individual masterpiece submission rid the program of extraneous classes and demonstrate efficient use of hierarchies (through super constructors, extends, etc.). LifeState, Alive, Dead, FireCellWorld, GameOfLifeCellWorld, and State are all classes that I wrote myself and refactored constantly throughout the course of the project. I believe that the code I am turning in for my masterpiece is clean, easily readable, and devoid of unnecessary, repetitive code. 